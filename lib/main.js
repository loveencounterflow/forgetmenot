// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CND, CRYPTO, D, FS, PATH, badge, debug, do_glob, echo, help, info, log, rpr, step, test, urge, warn, whisper, σ_globs, σ_memopath, σ_ref,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'FORGETMENOT/MAIN';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  PATH = require('path');

  FS = require('fs');

  CRYPTO = require('crypto');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  do_glob = require('glob');

  this.DATE = require('./date');

  σ_ref = Symbol["for"]('ref');

  σ_memopath = Symbol["for"]('path');

  σ_globs = Symbol["for"]('globs');

  this.create_memo = function(settings, handler) {

    /* Check for arity 1 or 2 */
    var Z, arity, autosave, expected, globs, got, key, keys, memo_path, name, ref, ref1, ref2, ref3, type_of_globs, type_of_handler, type_of_name, type_of_ref;
    switch (arity = arguments.length) {
      case 1:
        handler = settings;
        settings = null;
        break;
      case 2:
        null;
        break;
      default:
        throw new Error("expected 1 or 2 arguments, got " + arity);
    }

    /* check that we did receive a function for argument handler */
    if ((type_of_handler = CND.type_of(handler)) !== 'function') {
      throw new Error("expected a function for handler, got a " + type_of_handler);
    }

    /* return copy of memo when memo was passed in; otherwise, check that `settings` is a POD */
    if (settings != null) {
      if (!CND.isa_pod(settings)) {
        throw new Error("expected a POD, got a " + (CND.type_of(settings)));
      }
    }

    /* make sure no unknown keys have been passed in */
    if (!CND.is_subset((keys = Object.keys(settings)), this.create_memo._keys)) {
      expected = ((function() {
        var i, len, ref1, results;
        ref1 = this.create_memo._keys;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          key = ref1[i];
          results.push(rpr(key));
        }
        return results;
      }).call(this)).join(', ');
      got = ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          if (indexOf.call(this.create_memo._keys, key) < 0) {
            results.push(rpr(key));
          }
        }
        return results;
      }).call(this)).join(', ');
      throw new Error("expected " + expected + " as keys of settings, got " + got);
    }
    Z = null;
    autosave = ((settings != null ? settings['name'] : void 0) != null) && ((settings != null ? settings['ref'] : void 0) != null);
    name = (ref1 = settings != null ? settings['name'] : void 0) != null ? ref1 : '.forgetmenot-memo.json';
    globs = (ref2 = settings != null ? settings['globs'] : void 0) != null ? ref2 : [];
    ref = (ref3 = settings != null ? settings['ref'] : void 0) != null ? ref3 : '.';
    switch (type_of_name = CND.type_of(name)) {
      case 'text':
        null;
        break;
      default:
        throw new Error("expected a text for name, got a " + type_of_name);
    }
    switch (type_of_globs = CND.type_of(globs)) {
      case 'null':
        null;
        break;
      case 'list':
        null;
        break;
      case 'text':
        globs = [globs];
        break;
      default:
        throw new Error("expected a text or a list for globs, got a " + type_of_globs);
    }
    switch (type_of_ref = CND.type_of(ref)) {
      case 'text':
        if (autosave) {
          memo_path = PATH.resolve(ref, name);
          Z = this._new_memo_from_path(memo_path, settings);
        }
        break;
      default:
        throw new Error("expected a text or an object of type 'FORGETMENOT/memo', got a " + type_of_path);
    }
    if (Z == null) {
      Z = {
        '~isa': 'FORGETMENOT/memo',
        globs: globs.slice(0),
        ref: ref,
        name: name,
        autosave: autosave,
        store: {}
      };
    }
    step((function(_this) {
      return function*(resume) {
        var absolute_ref, error;
        absolute_ref = _this._get_ref(Z);
        if (!(yield _this.is_folder(Z, absolute_ref, resume))) {
          return handler(new Error("expected reference path to be a folder: " + absolute_ref));
        }
        try {
          yield _this.update(Z, resume);
        } catch (error1) {
          error = error1;
          return handler(error);
        }
        if (handler != null) {
          return handler(null, Z);
        }
      };
    })(this));
    return null;
  };

  this.create_memo._keys = ['globs', 'ref', 'name'];

  this._new_memo_from_path = function(path, settings) {

    /* Try to load memo object from file; return `null` if not found */
    var error, json;
    try {
      json = FS.readFileSync(path, {
        encoding: 'utf-8'
      });
    } catch (error1) {
      error = error1;
      if (error['code'] === 'ENOENT') {
        return null;
      }
      throw error;
    }

    /* TAINT perform sanity check on object structure */
    if (json.length === 0) {
      return null;
    }
    return JSON.parse(json);
  };

  this._resolve_paths = function(me) {
    var glob;
    if (me[σ_ref] != null) {
      return;
    }
    me[σ_ref] = PATH.resolve(process.cwd(), me['ref']);
    me[σ_memopath] = PATH.resolve(me[σ_ref], me['name']);
    me[σ_globs] = (function() {
      var i, len, ref1, results;
      ref1 = me['globs'];
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        glob = ref1[i];
        results.push(PATH.resolve(me[σ_ref], glob));
      }
      return results;
    })();
    return null;
  };

  this._get_ref = function(me) {
    this._resolve_paths(me);
    return me[σ_ref];
  };

  this._get_memopath = function(me) {
    this._resolve_paths(me);
    return me[σ_memopath];
  };

  this._get_globs = function(me) {
    this._resolve_paths(me);
    return me[σ_globs];
  };

  this._new_entry = function() {
    var P, R, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    R = {
      protocol: null,
      path: null,
      checksum: null,
      timestamp: null,
      status: null,
      value: null
    };
    if (P.length > 0) {
      Object.assign.apply(Object, [R].concat(slice.call(P)));
    }
    return R;
  };

  this.update = function(me, handler) {
    return this._update(me, false, handler);
  };

  this.force_update = function(me, handler) {
    return this._update(me, true, handler);
  };

  this._update = function(me, force, handler) {
    var ref, store;
    store = me.store;
    ref = this._get_ref(me);
    step((function(_this) {
      return function*(resume) {
        var checksum, glob, i, j, len, len1, new_checksum, new_timestamp, old_checksum, old_timestamp, path, path_checksum, paths, ref1, ref2, ref3, ref4, ref5, relative_path, status, target, timestamp;
        ref1 = _this._get_globs(me);
        for (i = 0, len = ref1.length; i < len; i++) {
          glob = ref1[i];
          paths = (yield do_glob(glob, resume));
          for (j = 0, len1 = paths.length; j < len1; j++) {
            path = paths[j];
            relative_path = PATH.relative(ref, path);
            path_checksum = _this.checksum_from_text(me, relative_path);
            new_checksum = (yield _this.checksum_from_path(me, path, resume));
            new_timestamp = (yield _this.timestamp_from_path(me, path, resume));
            old_checksum = (ref2 = (ref3 = store[path_checksum]) != null ? ref3['checksum'] : void 0) != null ? ref2 : null;
            old_timestamp = (ref4 = (ref5 = store[path_checksum]) != null ? ref5['timestamp'] : void 0) != null ? ref4 : null;
            if ((!force) && old_checksum === new_checksum) {
              status = 'same';
              checksum = old_checksum;
              timestamp = old_timestamp < new_timestamp ? old_timestamp : new_timestamp;
              if (old_timestamp == null) {
                throw new Error("### MEH ###");
              }
            } else {
              status = 'changed';
              checksum = new_checksum;
              timestamp = new_timestamp;
            }
            target = store[path_checksum] != null ? store[path_checksum] : store[path_checksum] = _this._new_entry(me, {
              protocol: 'file'
            });
            Object.assign(target, {
              path: relative_path,
              checksum: checksum,
              timestamp: timestamp,
              status: status
            });
          }
        }
        if (me['autosave']) {
          return _this.save(me, handler);
        } else {
          return handler(null, me);
        }
      };
    })(this));
    return null;
  };

  this.save = function(me, handler) {
    var json, path;
    if (handler == null) {
      handler = null;
    }
    json = JSON.stringify(me, null, ' ');
    path = this._get_memopath(me);
    if (handler != null) {
      step((function(_this) {
        return function*(resume) {
          yield FS.writeFile(path, json, resume);
          return handler(null, me);
        };
      })(this));
    } else {
      FS.writeFileSync(path, json);
    }
    return me;
  };

  this.set = function(me, name, value) {

    /* serialize, checksum, equality */
    var checksum, entry, json, key, locator, protocol, ref1, store, timestamp;
    store = me.store;
    timestamp = this.DATE.as_timestamp();
    protocol = 'cache';
    locator = protocol + "::" + name;
    key = this.checksum_from_text(me, locator);
    json = JSON.stringify(value);
    if (json === ((ref1 = store[key]) != null ? ref1['value'] : void 0)) {
      return;
    }

    /* TAINT no need for checksum when doing string comparison */
    checksum = null;
    entry = store[key] != null ? store[key] : store[key] = this._new_entry(me, {
      protocol: protocol
    });
    Object.assign(entry, {
      path: name,
      value: json,
      checksum: checksum,
      timestamp: timestamp
    });
    return me;
  };

  this.get_cache_entry = function(me, name, fallback) {
    var R, key, locator, protocol;
    protocol = 'cache';
    locator = protocol + "::" + name;
    key = this.checksum_from_text(me, locator);
    if ((R = me['store'][key]) == null) {
      if (fallback !== void 0) {
        return fallback;
      }
      throw new Error("no cache entry named " + (rpr(name)));
    }
    return R;
  };

  this.get = function(me, name, fallback) {
    var R;
    if ((R = this.get_cache_entry(me, name, null)) === null) {
      if (fallback !== void 0) {
        return fallback;
      }
      throw new Error("no cache entry named " + (rpr(name)));
    }
    return JSON.parse(R['value']);
  };

  this._file_entry_from_path = function(me, path) {

    /* TAINT make this a global emthod; unify interface with get / get_entry / set */
    var R, path_checksum;
    path_checksum = this.checksum_from_text(me, path);
    if ((R = me['store'][path_checksum]) == null) {
      throw new Error("no file registered with path " + (rpr(path)));
    }
    return R;
  };

  this.get_entry = function(me, locator) {
    var path, protocol, ref1;
    ref1 = locator.split('::'), protocol = ref1[0], path = ref1[1];
    switch (protocol) {
      case 'file':
        return this._file_entry_from_path(me, path);
      case 'cache':
        return this.get_cache_entry(me, path);
    }
    throw new Error("no stamper for protocol " + (rpr(protocol)));
  };

  this.checksum_from_path = function(me, path, fallback, handler) {
    var Z, arity, finished, hash, input;
    switch (arity = arguments.length) {
      case 3:
        handler = fallback;
        fallback = void 0;
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expect 3 or 4 arguments, got " + arity);
    }
    hash = CRYPTO.createHash('sha1');
    Z = null;
    finished = false;
    input = D.new_stream({
      path: path
    });
    input.on('error', function(error) {
      if (finished) {
        throw error;
      }
      finished = true;
      if (fallback !== void 0) {
        return handler(null, fallback);
      }
      return handler(error);
    });
    input.pipe(hash).pipe($((function(_this) {
      return function(buffer) {
        return Z = (buffer.toString('hex')).slice(0, 12);
      };
    })(this))).pipe($('finish', (function(_this) {
      return function() {
        return handler(null, Z);
      };
    })(this)));
    return null;
  };

  this.checksum_from_text = function(me, text, handler) {
    var R;
    if (handler == null) {
      handler = null;
    }
    R = (((CRYPTO.createHash('sha1')).update(text, 'utf8')).digest('hex')).slice(0, 12);
    if (handler != null) {
      handler(null, R);
    }
    return R;
  };

  this.timestamp_from_path = function(me, path, handler) {
    step((function(_this) {
      return function*(resume) {
        var error, stat;
        try {
          stat = (yield FS.stat(path, resume));
        } catch (error1) {
          error = error1;
          if (error['code'] !== 'ENOENT') {
            throw error;
          }
          return handler(null, null);
        }
        return handler(null, _this.DATE.as_timestamp(stat['mtime']));
      };
    })(this));
    return null;
  };

  this.is_folder = function(me, path, handler) {
    FS.stat(path, (function(_this) {
      return function(error, stat) {
        if (error != null) {
          if (error['code'] === 'ENOENT') {
            return handler(null, false);
          }
          return handler(error);
        }
        return handler(null, stat.isDirectory());
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
