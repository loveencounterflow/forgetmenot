// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CND, Crc32, D, FS, PATH, badge, debug, do_glob, echo, help, info, log, rpr, step, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'FORGETMENOT/MAIN';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  PATH = require('path');

  FS = require('fs');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  Crc32 = require('sse4_crc32');

  do_glob = require('glob');

  this.DATE = require('./date');

  this.new_cache = function(settings, handler) {
    var R, arity, autosave, cache, glob, globs, i, len, path, ref, ref1, ref2, ref3, ref4, type_of_cache, type_of_globs;
    switch (arity = arguments.length) {
      case 1:
        if (CND.isa_function(settings)) {
          handler = settings;
          settings = null;
        } else {
          handler = null;
        }
        break;
      case 2:
        null;
        break;
      default:
        throw new Error("expected 1 or 2 arguments, got " + arity);
    }
    if (settings != null) {
      if (!CND.isa_pod(settings)) {
        throw new Error("expected a POD, got a " + (CND.type_of(settings)));
      }
    }
    globs = (ref1 = settings != null ? settings['globs'] : void 0) != null ? ref1 : [];
    cache = (ref2 = settings != null ? settings['cache'] : void 0) != null ? ref2 : null;
    autosave = (ref3 = settings != null ? settings['autosave'] : void 0) != null ? ref3 : null;

    /* ??? `ref` will hold reference point of globs ??? */
    ref = (ref4 = settings != null ? settings['ref'] : void 0) != null ? ref4 : null;
    path = null;
    switch (type_of_globs = CND.type_of(globs)) {
      case 'null':
        null;
        break;
      case 'list':
        null;
        break;
      case 'text':
        globs = [globs];
        break;
      default:
        throw new Error("expected a text or a list for globs, got a " + type_of_globs);
    }
    switch (type_of_cache = CND.type_of(cache)) {
      case 'FORGETMENOT/cache':
        throw new Error("### MEH ### not implemented");
        break;
      case 'null':
        null;
        break;
      case 'text':
        path = cache;
        R = this._new_cache_from_path(path, settings);
        break;
      default:
        throw new Error("expected a text or an object of type 'FORGETMENOT/cache', got a " + type_of_cache);
    }
    if (R == null) {
      R = {
        '~isa': 'FORGETMENOT/cache',
        globs: [],
        path: path,
        files: {},
        autosave: false
      };
    }
    for (i = 0, len = globs.length; i < len; i++) {
      glob = globs[i];
      if (indexOf.call(R['globs'], glob) >= 0) {
        continue;
      }
      R['globs'].push(glob);
    }
    debug('44000', path);
    R['autosave'] = autosave != null ? autosave : path != null;
    if (handler != null) {
      return this.update(R, handler);
    }
    return R;
  };

  this._new_cache_from_path = function(path, settings) {

    /* Try to load cache object from file; return `null` if not found */
    var error, json;
    try {
      json = FS.readFileSync(path, {
        encoding: 'utf-8'
      });
    } catch (error1) {
      error = error1;
      if ((error['code'] === 'ENOENT') || json.length === 0) {
        return null;
      }
      throw error;
    }

    /* TAINT perform sanity check on object structure */
    if (json.length === 0) {
      return null;
    }
    return JSON.parse(json);
  };

  this.update = function(me, handler) {

    /* TAINT update timestamp only where checksum is new */
    var autosave, files;
    files = me.files, autosave = me.autosave;
    step((function(_this) {
      return function*(resume) {
        var checksum, glob, i, j, len, len1, new_checksum, new_timestamp, old_checksum, old_timestamp, path, path_checksum, paths, ref1, ref2, ref3, ref4, ref5, status, target, timestamp;
        ref1 = me['globs'];
        for (i = 0, len = ref1.length; i < len; i++) {
          glob = ref1[i];
          paths = (yield do_glob(glob, resume));
          for (j = 0, len1 = paths.length; j < len1; j++) {
            path = paths[j];
            path_checksum = _this.checksum_from_text(me, path, null);
            new_checksum = (yield _this.checksum_from_path(me, path, resume));
            new_timestamp = (yield _this.timestamp_from_path(me, path, resume));
            old_checksum = (ref2 = (ref3 = files[path_checksum]) != null ? ref3['checksum'] : void 0) != null ? ref2 : null;
            old_timestamp = (ref4 = (ref5 = files[path_checksum]) != null ? ref5['timestamp'] : void 0) != null ? ref4 : null;
            if (old_checksum === new_checksum) {
              status = 'same';
              checksum = old_checksum;
              timestamp = old_timestamp < new_timestamp ? old_timestamp : new_timestamp;
              if (old_timestamp == null) {
                throw new Error("### MEH ###");
              }
            } else {
              status = 'changed';
              checksum = new_checksum;
              timestamp = new_timestamp;
            }

            /*
            if files[ path_checksum ]?
              files[ path_checksum ][ 'previous-checksum'  ] = files[ path_checksum ][ 'checksum'  ]
              files[ path_checksum ][ 'previous-timestamp' ] = files[ path_checksum ][ 'timestamp' ]
             */
            target = files[path_checksum] != null ? files[path_checksum] : files[path_checksum] = {};
            Object.assign(target, {
              path: path,
              checksum: checksum,
              timestamp: timestamp,
              status: status
            });
          }
        }
        if (autosave) {
          return _this.save(me, handler);
        } else {
          return handler(null, me);
        }
      };
    })(this));
    return null;
  };

  this.save = function(me, handler) {
    step((function(_this) {
      return function*(resume) {
        var path;
        if ((path = me['path']) == null) {
          return handler(new Error("unable to save without path given"));
        }
        yield FS.writeFile(path, JSON.stringify(me, null, ' '), resume);
        return handler(null, me);
      };
    })(this));
    return null;
  };

  this.checksum_from_path = function(me, path, fallback, handler) {
    var arity, crc32, finished, input;
    switch (arity = arguments.length) {
      case 3:
        handler = fallback;
        fallback = void 0;
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expect 3 or 4 arguments, got " + arity);
    }
    crc32 = new Crc32.CRC32();
    finished = false;
    input = D.new_stream({
      path: path
    });
    input.on('error', function(error) {
      if (finished) {
        throw error;
      }
      finished = true;
      if (fallback !== void 0) {
        return handler(null, fallback);
      }
      return handler(error);
    });
    input.pipe($(function(data, send) {
      return crc32.update(data);
    })).pipe($('finish', (function(_this) {
      return function() {
        if (finished) {
          return;
        }
        finished = true;
        return handler(null, crc32.crc());
      };
    })(this)));
    return null;
  };

  this.checksum_from_text = function(me, text, handler) {
    var R;
    if (handler == null) {
      handler = null;
    }
    R = Crc32.calculate(text);
    if (handler != null) {
      handler(null, R);
    }
    return R;
  };

  this.timestamp_from_path = function(me, path, handler) {
    step((function(_this) {
      return function*(resume) {
        var error, stat;
        try {
          stat = (yield (require('fs')).stat(path, resume));
        } catch (error1) {
          error = error1;
          if (error['code'] !== 'ENOENT') {
            throw error;
          }
          return handler(null, null);
        }
        return handler(null, _this.DATE.as_timestamp(stat['timestamp']));
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
