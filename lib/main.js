// Generated by CoffeeScript 1.11.1
(function() {
  var $, $async, CND, CRYPTO, D, FS, PATH, badge, debug, do_glob, echo, help, info, log, rpr, step, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'FORGETMENOT/MAIN';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  PATH = require('path');

  FS = require('fs');

  CRYPTO = require('crypto');

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  do_glob = require('glob');

  this.DATE = require('./date');

  this.new_memo = function(settings, handler) {
    var R, arity, autosave, expected, glob, globs, got, i, key, keys, len, path, ref, ref1, ref2, ref3, ref4, type_of_globs, type_of_path;
    switch (arity = arguments.length) {
      case 1:
        if (CND.isa_function(settings)) {
          handler = settings;
          settings = null;
        } else {
          handler = null;
        }
        break;
      case 2:
        null;
        break;
      default:
        throw new Error("expected 1 or 2 arguments, got " + arity);
    }
    if (settings != null) {
      if (CND.isa(settings, 'FORGETMENOT/memo')) {
        R = CND.deep_copy(settings);
        if (handler != null) {
          return this.update(R, handler);
        }
        return R;
      }
      if (!CND.isa_pod(settings)) {
        throw new Error("expected a POD or a FORGETMENOT/memo object, got a " + (CND.type_of(settings)));
      }
    }
    if (!CND.is_subset((keys = Object.keys(settings)), this.new_memo._keys)) {
      expected = ((function() {
        var i, len, ref1, results;
        ref1 = this.new_memo._keys;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          key = ref1[i];
          results.push(rpr(key));
        }
        return results;
      }).call(this)).join(', ');
      got = ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          if (indexOf.call(this.new_memo._keys, key) < 0) {
            results.push(rpr(key));
          }
        }
        return results;
      }).call(this)).join(', ');
      throw new Error("expected " + expected + " as keys of settings, got " + got);
    }
    globs = (ref1 = settings != null ? settings['globs'] : void 0) != null ? ref1 : [];
    path = (ref2 = settings != null ? settings['path'] : void 0) != null ? ref2 : null;
    autosave = (ref3 = settings != null ? settings['autosave'] : void 0) != null ? ref3 : null;

    /* ??? `ref` will hold reference point of globs ??? */
    ref = (ref4 = settings != null ? settings['ref'] : void 0) != null ? ref4 : null;
    switch (type_of_globs = CND.type_of(globs)) {
      case 'null':
        null;
        break;
      case 'list':
        null;
        break;
      case 'text':
        globs = [globs];
        break;
      default:
        throw new Error("expected a text or a list for globs, got a " + type_of_globs);
    }
    switch (type_of_path = CND.type_of(path)) {
      case 'null':
        null;
        break;
      case 'text':
        R = this._new_memo_from_path(path, settings);
        break;
      default:
        throw new Error("expected a text or an object of type 'FORGETMENOT/memo', got a " + type_of_path);
    }
    if (R == null) {
      R = {
        '~isa': 'FORGETMENOT/memo',
        globs: [],
        path: path,
        files: {},
        autosave: false,
        cache: {}
      };
    }
    for (i = 0, len = globs.length; i < len; i++) {
      glob = globs[i];
      if (indexOf.call(R['globs'], glob) >= 0) {
        continue;
      }
      R['globs'].push(glob);
    }
    R['autosave'] = autosave != null ? autosave : path != null;
    if (handler != null) {
      return this.update(R, handler);
    }
    return R;
  };

  this.new_memo._keys = ['globs', 'path', 'autosave', 'ref'];

  this._new_memo_from_path = function(path, settings) {

    /* Try to load memo object from file; return `null` if not found */
    var error, json;
    try {
      json = FS.readFileSync(path, {
        encoding: 'utf-8'
      });
    } catch (error1) {
      error = error1;
      if ((error['code'] === 'ENOENT') || json.length === 0) {
        return null;
      }
      throw error;
    }

    /* TAINT perform sanity check on object structure */
    if (json.length === 0) {
      return null;
    }
    return JSON.parse(json);
  };

  this.update = function(me, handler) {

    /* TAINT update timestamp only where checksum is new */
    var autosave, files;
    files = me.files, autosave = me.autosave;
    step((function(_this) {
      return function*(resume) {
        var checksum, glob, i, j, len, len1, new_checksum, new_timestamp, old_checksum, old_timestamp, path, path_checksum, paths, ref1, ref2, ref3, ref4, ref5, status, target, timestamp;
        ref1 = me['globs'];
        for (i = 0, len = ref1.length; i < len; i++) {
          glob = ref1[i];
          paths = (yield do_glob(glob, resume));
          for (j = 0, len1 = paths.length; j < len1; j++) {
            path = paths[j];
            path_checksum = _this.checksum_from_text(me, path, null);
            new_checksum = (yield _this.checksum_from_path(me, path, resume));
            new_timestamp = (yield _this.timestamp_from_path(me, path, resume));
            old_checksum = (ref2 = (ref3 = files[path_checksum]) != null ? ref3['checksum'] : void 0) != null ? ref2 : null;
            old_timestamp = (ref4 = (ref5 = files[path_checksum]) != null ? ref5['timestamp'] : void 0) != null ? ref4 : null;
            help('33209', old_checksum, new_checksum);
            help('33209', old_timestamp, new_timestamp);
            if (old_checksum === new_checksum) {
              status = 'same';
              checksum = old_checksum;
              timestamp = old_timestamp < new_timestamp ? old_timestamp : new_timestamp;
              if (old_timestamp == null) {
                throw new Error("### MEH ###");
              }
            } else {
              status = 'changed';
              checksum = new_checksum;
              timestamp = new_timestamp;
            }

            /*
            if files[ path_checksum ]?
              files[ path_checksum ][ 'previous-checksum'  ] = files[ path_checksum ][ 'checksum'  ]
              files[ path_checksum ][ 'previous-timestamp' ] = files[ path_checksum ][ 'timestamp' ]
             */
            target = files[path_checksum] != null ? files[path_checksum] : files[path_checksum] = {};
            Object.assign(target, {
              path: path,
              checksum: checksum,
              timestamp: timestamp,
              status: status
            });
          }
        }
        if (autosave) {
          return _this.save(me, handler);
        } else {
          return handler(null, me);
        }
      };
    })(this));
    return null;
  };

  this.save = function(me, handler) {
    var json;
    if (handler == null) {
      handler = null;
    }
    json = JSON.stringify(me, null, ' ');
    if (handler != null) {
      step((function(_this) {
        return function*(resume) {
          var path;
          if ((path = me['path']) == null) {
            return handler(new Error("unable to save without path given"));
          }
          yield FS.writeFile(path, json, resume);
          return handler(null, me);
        };
      })(this));
    } else {
      FS.writeFileSync(path, json);
    }
    return me;
  };

  this.set = function(me, key, value) {

    /* serialize, checksum, equality */
    var base, target, timestamp;
    timestamp = this.DATE.as_timestamp();
    target = (base = me['cache'])['key'] != null ? base['key'] : base['key'] = {};
    Object.assign(target, {
      value: value,
      timestamp: timestamp
    });
    return me;
  };

  this.get_entry = function(me, key, fallback) {
    var R;
    if ((R = me['cache']['key']) == null) {
      if (fallback !== void 0) {
        return fallback;
      }
      throw new Error("no such key: " + (rpr(key)));
    }
    return R;
  };

  this.get = function(me, key, fallback) {
    var R;
    if ((R = this.get_entry(me, key, null)) === null) {
      if (fallback !== void 0) {
        return fallback;
      }
      throw new Error("no such key: " + (rpr(key)));
    }
    return R['value'];
  };

  this.checksum_from_path = function(me, path, fallback, handler) {
    var Z, arity, finished, hash, input;
    switch (arity = arguments.length) {
      case 3:
        handler = fallback;
        fallback = void 0;
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expect 3 or 4 arguments, got " + arity);
    }
    hash = CRYPTO.createHash('sha1');
    Z = null;
    finished = false;
    input = D.new_stream({
      path: path
    });
    input.on('error', function(error) {
      if (finished) {
        throw error;
      }
      finished = true;
      if (fallback !== void 0) {
        return handler(null, fallback);
      }
      return handler(error);
    });
    input.pipe(hash).pipe($((function(_this) {
      return function(buffer) {
        return Z = (buffer.toString('hex')).slice(0, 12);
      };
    })(this))).pipe($('finish', (function(_this) {
      return function() {
        return handler(null, Z);
      };
    })(this)));
    return null;
  };

  this.checksum_from_text = function(me, text, handler) {
    var R;
    if (handler == null) {
      handler = null;
    }
    R = (((CRYPTO.createHash('sha1')).update(text, 'utf8')).digest('hex')).slice(0, 12);
    if (handler != null) {
      handler(null, R);
    }
    return R;
  };

  this.timestamp_from_path = function(me, path, handler) {
    step((function(_this) {
      return function*(resume) {
        var error, stat;
        try {
          stat = (yield (require('fs')).stat(path, resume));
        } catch (error1) {
          error = error1;
          if (error['code'] !== 'ENOENT') {
            throw error;
          }
          return handler(null, null);
        }
        return handler(null, _this.DATE.as_timestamp(stat['mtime']));
      };
    })(this));
    return null;
  };

}).call(this);

//# sourceMappingURL=main.js.map
